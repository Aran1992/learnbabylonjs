<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
    <meta content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"
          name="viewport"/>
    <title>Babylon - Getting Started</title>
    <!--- Link to the last version of BabylonJS --->
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://raw.githubusercontent.com/BabylonJS/Babylon.js/master/dist/preview%20release/loaders/babylon.glTFFileLoader.js"></script>
    <script src="https://cdn.babylonjs.com/ammo.js"></script>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            position: absolute;
        }

        #control {
            position: absolute;
            z-index: 1000;
        }
    </style>
</head>
<body>
<div id="control">
    <button onclick="repeat();">重复一遍</button>
</div>
<canvas></canvas>
<script>
    let restitution = 0.1;
    let friction = 0.5;
    let saveList = [];
    let shakeList = [
        [10, () => -5 - Math.random()],
        [20, () => 5 + Math.random()],
        [30, () => -3 - Math.random()],
        [40, () => 3 + Math.random()],
        [50, () => -2 - Math.random()],
        [60, () => 2 + Math.random()],
        [70, () => -1 * Math.random()],
        [80, () => 1 * Math.random()],
        [90, undefined],
    ];

    function repeat() {
        restart(saveList);
    }

    function restart(inputList) {
        if (inputList === undefined) {
            saveList = [];
        }
        // get the canvas DOM element
        let canvas = document.getElementsByTagName('canvas')[0];
        canvas.parentElement.removeChild(canvas);
        canvas = document.createElement('canvas');
        document.body.appendChild(canvas);

        // load the 3D engine
        let engine = new BABYLON.Engine(canvas, true);

        // createScene function that creates and return the scene
        let createScene = function () {
            // create a basic BJS Scene object
            let scene = new BABYLON.Scene(engine);
            scene.enablePhysics(undefined, new BABYLON.AmmoJSPlugin(false));

            // Create a FreeCamera, and set its position to (x:0, y:5, z:-10).
            let camera = new BABYLON.FreeCamera('camera', new BABYLON.Vector3(0, 5, -10), scene);

            // Target the camera to scene origin.
            camera.setTarget(BABYLON.Vector3.Zero());

            // Attach the camera to the canvas.
            camera.attachControl(canvas, false);

            // Create a basic light, aiming 0,1,0 - meaning, to the sky.
            let light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0, 1, 0), scene);

            BABYLON.SceneLoader.ImportMesh("", "./touzi/", "touzi.gltf", scene, (newMeshes) => {
                let createDices = () => {
                    let dices = [];
                    let count = 5;
                    let size = 0.5;
                    let modelScale2Size = 0.005875;
                    let modelScale = size / modelScale2Size;
                    for (let i = 0; i < count; i++) {
                        let model = newMeshes[0].clone("", null);
                        model.scaling = new BABYLON.Vector3(modelScale, modelScale, modelScale);
                        let collider = BABYLON.Mesh.CreateBox("", size, scene);
                        collider.physicsImpostor = new BABYLON.PhysicsImpostor(collider, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 0}, scene);
                        collider.isVisible = false;
                        let dice = new BABYLON.Mesh("", scene);
                        dice.addChild(model);
                        dice.addChild(collider);
                        dice.physicsImpostor = new BABYLON.PhysicsImpostor(dice, BABYLON.PhysicsImpostor.NoImpostor, {
                            mass: 3,
                            friction,
                            restitution
                        }, scene);
                        dices.push(dice);
                    }
                    return dices;
                };

                let createDiceCup = () => {
                    let diameter = 3;
                    let thickness = 0.2;
                    let height = 3;
                    let tessellation = 8;
                    let percent = 0.5;
                    let mat0 = new BABYLON.StandardMaterial("mat0", scene);
                    mat0.opacityTexture = new BABYLON.Texture("bg.png", scene);
                    let createThickness = (name) => {
                        return BABYLON.MeshBuilder.CreateCylinder(name, {
                            diameter: diameter,
                            height: thickness,
                            tessellation: tessellation,
                        }, scene);
                    };
                    let createSide = (index, top) => {
                        let radian = Math.PI / tessellation;
                        let width = diameter / 2 * Math.sin(radian) * 2;
                        let side = new BABYLON.MeshBuilder.CreateBox(`side${index}`, {
                            width: width,
                            height: height,
                            depth: thickness,
                        }, scene);
                        let rotation = radian + radian * 2 * index;
                        let innerRadius = diameter / 2 * Math.cos(radian) + thickness / 2;
                        side.rotationQuaternion = new BABYLON.Quaternion.RotationAxis(new BABYLON.Vector3(0, 1, 0), rotation);
                        // console.log(side.rotationQuaternion && side.rotationQuaternion.toEulerAngles());
                        side.position.x = innerRadius * Math.sin(rotation);
                        side.position.y = -(height + thickness) / 2;
                        side.position.z = innerRadius * Math.cos(rotation);
                        side.physicsImpostor = new BABYLON.PhysicsImpostor(side, BABYLON.PhysicsImpostor.BoxImpostor, {
                            mass: 10,
                            friction: friction,
                            restitution: restitution,
                        }, scene);
                        side.parent = top;
                        return side;
                    };
                    let top = createThickness("top");
                    top.position.y = (height + thickness) / 2;
                    // console.log(top.rotationQuaternion && top.rotationQuaternion.toEulerAngles());
                    // top.material = mat0;
                    let bottom = createThickness("bottom");
                    bottom.position.y = -height - thickness;
                    let sides = [];
                    for (let i = 0; i < tessellation; i++) {
                        sides.push(createSide(i, top));
                        if (i >= tessellation * (1 - percent) / 2 && i < tessellation * ((1 - percent) / 2 + percent)) {
                            sides[i].material = mat0;
                        }
                    }
                    bottom.physicsImpostor = new BABYLON.PhysicsImpostor(bottom, BABYLON.PhysicsImpostor.CylinderImpostor, {
                        mass: 100,
                        friction: friction,
                        restitution: restitution,
                    }, scene);
                    bottom.parent = top;
                    top.physicsImpostor = new BABYLON.PhysicsImpostor(top, BABYLON.PhysicsImpostor.CylinderImpostor, {
                        mass: 10,
                        friction: friction,
                        restitution: restitution,
                    }, scene);
                    return top;
                };

                let createHolder = (diceCup) => {
                    let b = 0.1;
                    let holder = BABYLON.MeshBuilder.CreateSphere("holder", {diameter: b, segments: 4}, scene);
                    // the center mesh that turns the wheel
                    holder.physicsImpostor = new BABYLON.PhysicsImpostor(holder, BABYLON.PhysicsImpostor.SphereImpostor, {mass: 0});
                    let joint1 = new BABYLON.HingeJoint({
                        mainPivot: new BABYLON.Vector3(0, 0, 0),
                        connectedPivot: new BABYLON.Vector3(0, 0, 0),
                        mainAxis: new BABYLON.Vector3(0, 0, -1),
                        connectedAxis: new BABYLON.Vector3(0, 0, -1),
                        nativeParams: {}
                    });
                    // add the joint and the motor
                    holder.physicsImpostor.addJoint(diceCup.physicsImpostor, joint1);
                    let frame = 0;
                    scene.onBeforeRenderObservable.add(() => {
                        let flag = false;
                        for (let i = 0; i < shakeList.length; i++) {
                            if (frame < shakeList[i][0]) {
                                flag = true;
                                if (shakeList[i][1]) {
                                    let z;
                                    if (inputList && inputList[i] !== undefined) {
                                        z = inputList[i];
                                    } else {
                                        if (saveList[i] === undefined) {
                                            saveList[i] = shakeList[i][1]();
                                        }
                                        z = saveList[i];
                                    }
                                    diceCup.physicsImpostor.setAngularVelocity(new BABYLON.Vector3(0, 0, z));
                                } else {
                                    if (diceCup.rotationQuaternion) {
                                        let a = diceCup.rotationQuaternion.toEulerAngles();
                                        console.log(a.z / Math.PI * 180);
                                        let time = (shakeList[shakeList.length - 1][0] - frame) / 60;
                                        let v = -a.z / time;
                                        console.log(v);
                                        diceCup.physicsImpostor.setAngularVelocity(new BABYLON.Vector3(0, 0, v));
                                    }
                                }
                                break;
                            }
                        }
                        if (!flag) {
                            diceCup.rotationQuaternion = new BABYLON.Quaternion.RotationAxis(new BABYLON.Vector3(0, 0, 0), 0);
                        }
                        frame++;
                    });
                };

                createDices();
                let diceCup = createDiceCup();
                createHolder(diceCup);
            });

            return scene;
        };

        // call the createScene function
        let scene = createScene();
        // run the render loop
        engine.runRenderLoop(function () {
            scene.render();
        });

        // the canvas/window resize event handler
        window.addEventListener('resize', function () {
            engine.resize();
        });
    }

    window.addEventListener('DOMContentLoaded', function () {
        restart();
    });
</script>
</body>
</html>
